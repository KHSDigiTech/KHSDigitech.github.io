<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scholarship Exam Problems & Solutions</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #f5f5f5;
        }
        
        .header {
            background: linear-gradient(135deg, #7c3aed 0%, #4c1d95 100%);
            color: white;
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 2rem;
        }

        .content-section {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .problem-card {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #7c3aed;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        
        .easy { background: #dcfce7; color: #166534; }
        .medium { background: #fef3c7; color: #92400e; }
        .hard { background: #fecaca; color: #991b1b; }

        .problem-header {
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 1rem;
            margin-bottom: 1.5rem;
        }

        .problem-title {
            color: #4c1d95;
            margin: 0 0 0.5rem 0;
            font-size: 1.4rem;
            font-weight: 600;
        }
        
        .problem-description {
            background: #f8fafc;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
        }
        
        .solution-approach {
            background: #f0fdf4;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
        }
        
        .complexity-analysis {
            background: #fef7ff;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
        }
        
        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 1rem 0;
            font-size: 0.9rem;
        }
        
        .back-link {
            display: inline-block;
            margin-bottom: 1rem;
            color: #7c3aed;
            text-decoration: none;
        }

        .back-link:hover {
            text-decoration: underline;
        }
        
        .scholarship-tips {
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
        }
        
        .scholarship-tips h4 {
            color: #92400e;
            margin-top: 0;
        }
        
        .test-cases {
            background: #eff6ff;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
        }
        
        .category-header {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 1.5rem;
            border-radius: 12px;
            border: 2px solid #7c3aed;
            margin: 2rem 0 1rem 0;
            text-align: center;
        }
        
        .category-header h2 {
            color: #4c1d95;
            margin: 0;
            font-size: 1.5rem;
        }

        .highlight {
            background: #fff3cd;
            padding: 1rem;
            border-left: 4px solid #ffc107;
            border-radius: 5px;
            margin: 1rem 0;
        }

        .checklist {
            background: #d4edda;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .quick-reference {
            background: #e8f5e8;
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid #4caf50;
            margin: 1rem 0;
        }

        .method-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 1rem 0;
        }

        .method-item {
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #7c3aed;
        }

        .method-item h5 {
            color: #4c1d95;
            margin-top: 0;
            margin-bottom: 0.8rem;
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 2rem 0;
        }

        .prev-next-link {
            display: inline-block;
            background: #7c3aed;
            color: white;
            padding: 0.8rem 1.5rem;
            text-decoration: none;
            border-radius: 5px;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        .prev-next-link:hover {
            background: #4c1d95;
        }

        .jump-to-section {
            background: #f8fafc;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .jump-to-section a {
            color: #7c3aed;
            text-decoration: none;
            margin-right: 1rem;
            font-weight: 500;
        }

        .jump-to-section a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Scholarship Study Guide</a>

    <div class="header">
        <h1>Scholarship Exam Problems</h1>
        <p>20 Essential Problems with Detailed Analysis & Solutions</p>
    </div>

    <div class="content-section">
        <h2>üéØ How to Use This Resource</h2>
        <ul>
            <li>Each problem includes multiple solution approaches and complexity analysis</li>
            <li>Work through problems systematically, focusing on understanding rather than memorizing</li>
            <li>Use the AI prompts provided to get additional help when needed</li>
            <li>Practice implementing solutions in your preferred programming language</li>
            <li>Focus on the critical analysis and justification sections for scholarship-level responses</li>
        </ul>

        <div class="jump-to-section">
            <h4>Quick Navigation:</h4>
            <a href="#algorithms">Algorithm Analysis</a>
            <a href="#graphs">Graph Theory</a>
            <a href="#dynamic">Dynamic Programming</a>
            <a href="#data-structures">Data Structures</a>
            <a href="#mathematical">Mathematical</a>
            <a href="#greedy">Greedy Algorithms</a>
            <a href="#patterns">Problem Patterns</a>
            <a href="#advanced">Advanced Topics</a>
        </div>
    </div>

    <div class="category-header" id="algorithms">
        <h2>Category 1: Algorithm Analysis & String Processing</h2>
    </div>

    <div class="problem-card">
        <div class="problem-header">
            <h3 class="problem-title">1. Palindrome Checker with Optimization</h3>
            <span class="difficulty-badge medium">Medium</span>
        </div>
        
        <div class="problem-description">
            <h4>Problem Statement:</h4>
            <p>Given a function that checks if a string is a palindrome by reversing the string and comparing, analyze its efficiency and create an optimized version. Handle edge cases and provide comprehensive testing.</p>
            
            <p><strong>Example Input:</strong> "racecar", "hello", "", "a"</p>
            <p><strong>Expected Skills:</strong> Code tracing, algorithm optimization, edge case handling</p>
        </div>

        <div class="solution-approach">
            <h4>Optimal Solution Approach:</h4>
            <ol>
                <li><strong>Two-pointer technique:</strong> Compare characters from start and end moving inward</li>
                <li><strong>Early termination:</strong> Return false immediately when mismatch found</li>
                <li><strong>Case handling:</strong> Consider empty strings, single characters</li>
                <li><strong>Space optimization:</strong> No additional string creation needed</li>
            </ol>
        </div>

        <div class="code-block">
def isPalindrome(s):
    if len(s) <= 1:
        return True
    
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True
        </div>

        <div class="complexity-analysis">
            <h4>Complexity Analysis:</h4>
            <ul>
                <li><strong>Original (naive) approach:</strong> O(n) time, O(n) space (creates reversed string)</li>
                <li><strong>Optimized approach:</strong> O(n) time, O(1) space</li>
                <li><strong>Best case:</strong> O(1) when first and last characters differ</li>
                <li><strong>Worst case:</strong> O(n) when string is palindrome or differs at center</li>
            </ul>
        </div>

        <div class="scholarship-tips">
            <h4>Scholarship-Level Analysis:</h4>
            <ul>
                <li>Discuss why space optimization matters for large strings</li>
                <li>Compare with other approaches (recursive, using built-in reverse)</li>
                <li>Explain early termination benefits</li>
                <li>Consider Unicode and case-sensitivity variations</li>
            </ul>
        </div>
    </div>

    <div class="problem-card">
        <div class="problem-header">
            <h3 class="problem-title">2. Longest Common Substring</h3>
            <span class="difficulty-badge hard">Hard</span>
        </div>
        
        <div class="problem-description">
            <h4>Problem Statement:</h4>
            <p>Find the longest common substring between two strings. Optimize for both time and space complexity.</p>
            
            <p><strong>Example:</strong> "ABABC" and "BABCA" ‚Üí "BABC" (length 4)</p>
            <p><strong>Expected Skills:</strong> Dynamic programming, space optimization, algorithm comparison</p>
        </div>

        <div class="solution-approach">
            <h4>Multiple Solution Approaches:</h4>
            <ol>
                <li><strong>Brute Force:</strong> Check all substrings - O(n¬≥) time</li>
                <li><strong>Dynamic Programming:</strong> 2D table approach - O(n¬≤) time, O(n¬≤) space</li>
                <li><strong>Space Optimized DP:</strong> Use rolling array - O(n¬≤) time, O(n) space</li>
                <li><strong>Suffix Array/Tree:</strong> Advanced approach - O(n log n) time</li>
            </ol>
        </div>

        <div class="complexity-analysis">
            <h4>DP Solution Analysis:</h4>
            <ul>
                <li><strong>Time Complexity:</strong> O(m √ó n) where m, n are string lengths</li>
                <li><strong>Space Complexity:</strong> O(min(m, n)) with optimization</li>
                <li><strong>Recurrence:</strong> dp[i][j] = dp[i-1][j-1] + 1 if chars match, else 0</li>
            </ul>
        </div>
    </div>

    <div class="category-header" id="graphs">
        <h2>Category 2: Graph Theory & Pathfinding</h2>
    </div>

    <div class="problem-card">
        <div class="problem-header">
            <h3 class="problem-title">3. Knight's Minimum Moves</h3>
            <span class="difficulty-badge medium">Medium</span>
        </div>
        
        <div class="problem-description">
            <h4>Problem Statement:</h4>
            <p>Calculate the minimum number of moves for a knight to travel from one square to another on an N√óN chessboard. Handle multiple queries efficiently.</p>
            
            <p><strong>Input:</strong> Board size N, start position (x1,y1), end position (x2,y2)</p>
            <p><strong>Output:</strong> Minimum number of moves</p>
        </div>

        <div class="solution-approach">
            <h4>BFS Solution Approach:</h4>
            <ol>
                <li><strong>Model as graph:</strong> Each square is a node, knight moves are edges</li>
                <li><strong>BFS from start:</strong> Guarantees shortest path in unweighted graph</li>
                <li><strong>8 possible moves:</strong> Knight's L-shaped movement pattern</li>
                <li><strong>Boundary checking:</strong> Ensure moves stay within board</li>
            </ol>
        </div>

        <div class="code-block">
from collections import deque

def knightMinMoves(n, start, end):
    if start == end:
        return 0
    
    moves = [(-2,-1), (-2,1), (-1,-2), (-1,2), 
             (1,-2), (1,2), (2,-1), (2,1)]
    
    queue = deque([(start[0], start[1], 0)])
    visited = set([start])
    
    while queue:
        x, y, dist = queue.popleft()
        
        for dx, dy in moves:
            nx, ny = x + dx, y + dy
            
            if (0 <= nx < n and 0 <= ny < n and 
                (nx, ny) not in visited):
                
                if (nx, ny) == end:
                    return dist + 1
                
                queue.append((nx, ny, dist + 1))
                visited.add((nx, ny))
    
    return -1  # Should never reach here on valid board
        </div>

        <div class="complexity-analysis">
            <h4>Complexity Analysis:</h4>
            <ul>
                <li><strong>Time Complexity:</strong> O(N¬≤) - worst case visits all squares</li>
                <li><strong>Space Complexity:</strong> O(N¬≤) - for visited set and queue</li>
                <li><strong>Optimal:</strong> BFS guarantees minimum moves (shortest path)</li>
                <li><strong>Alternative:</strong> A* with Manhattan distance heuristic for larger boards</li>
            </ul>
        </div>

        <div class="test-cases">
            <h4>Test Cases to Consider:</h4>
            <ul>
                <li><strong>Same position:</strong> (1,1) to (1,1) ‚Üí 0 moves</li>
                <li><strong>Adjacent squares:</strong> Often require 3 moves due to knight movement</li>
                <li><strong>Opposite corners:</strong> Maximum distance on board</li>
                <li><strong>Minimum board size:</strong> 4√ó4 (smaller boards may have unreachable squares)</li>
            </ul>
        </div>
    </div>

    <div class="category-header" id="dynamic">
        <h2>Category 3: Dynamic Programming & Optimization</h2>
    </div>

    <div class="problem-card">
        <div class="problem-header">
            <h3 class="problem-title">4. 0/1 Knapsack Problem</h3>
            <span class="difficulty-badge medium">Medium</span>
        </div>
        
        <div class="problem-description">
            <h4>Problem Statement:</h4>
            <p>Given items with weights and values, and a knapsack capacity, find the maximum value that can be achieved. Items cannot be split.</p>
            
            <p><strong>Example:</strong> Capacity=5, Items=[(weight=1,value=3), (2,5), (5,7)] ‚Üí Max value=8</p>
            <p><strong>Expected Skills:</strong> DP optimization, space complexity reduction, solution reconstruction</p>
        </div>

        <div class="solution-approach">
            <h4>Progressive Solution Development:</h4>
            <ol>
                <li><strong>Recursive with Memoization:</strong> Top-down approach</li>
                <li><strong>2D DP Table:</strong> Bottom-up with full table</li>
                <li><strong>Space Optimized:</strong> 1D array using rolling technique</li>
                <li><strong>Solution Tracking:</strong> Reconstruct which items were selected</li>
            </ol>
        </div>

        <div class="code-block">
def knapsack_optimized(capacity, weights, values, n):
    # Space optimized DP - O(capacity) space
    dp = [0] * (capacity + 1)
    
    for i in range(n):
        # Traverse backwards to avoid using updated values
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], 
                       dp[w - weights[i]] + values[i])
    
    return dp[capacity]
        </div>

        <div class="complexity-analysis">
            <h4>Complexity Analysis:</h4>
            <ul>
                <li><strong>Time Complexity:</strong> O(n √ó capacity) for all approaches</li>
                <li><strong>Space Complexity:</strong></li>
                <ul>
                    <li>2D DP: O(n √ó capacity)</li>
                    <li>Space optimized: O(capacity)</li>
                    <li>With solution tracking: O(n √ó capacity)</li>
                </ul>
                <li><strong>Pseudo-polynomial:</strong> Complexity depends on capacity value, not input size</li>
            </ul>
        </div>

        <div class="scholarship-tips">
            <h4>Scholarship Analysis Points:</h4>
            <ul>
                <li>Explain why greedy approach fails (value/weight ratio)</li>
                <li>Discuss space-time tradeoff between optimized and solution-tracking versions</li>
                <li>Compare with fractional knapsack (greedy works there)</li>
                <li>Mention NP-completeness and why DP is pseudo-polynomial</li>
            </ul>
        </div>
    </div>

    <div class="category-header" id="data-structures">
        <h2>Category 4: Advanced Data Structures</h2>
    </div>

    <div class="problem-card">
        <div class="problem-header">
            <h3 class="problem-title">5. Sliding Window Maximum</h3>
            <span class="difficulty-badge hard">Hard</span>
        </div>
        
        <div class="problem-description">
            <h4>Problem Statement:</h4>
            <p>Given an array and window size k, find the maximum element in each sliding window. Extend to handle minimum, sum, and multiple queries efficiently.</p>
            
            <p><strong>Example:</strong> [1,3,-1,-3,5,3,6,7], k=3 ‚Üí [3,3,5,5,6,7]</p>
            <p><strong>Expected Skills:</strong> Deque usage, amortized complexity analysis, data structure design</p>
        </div>

        <div class="solution-approach">
            <h4>Solution Approaches:</h4>
            <ol>
                <li><strong>Brute Force:</strong> Check each window - O(nk)</li>
                <li><strong>Deque (Monotonic Queue):</strong> Maintain decreasing order - O(n)</li>
                <li><strong>Segment Tree:</strong> Range max queries - O(n log n)</li>
                <li><strong>Sparse Table:</strong> Precomputed range queries - O(n log n) preprocessing</li>
            </ol>
        </div>

        <div class="code-block">
from collections import deque

def sliding_window_maximum(nums, k):
    dq = deque()  # Store indices
    result = []
    
    for i in range(len(nums)):
        # Remove indices outside current window
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # Remove smaller elements from rear
        while dq and nums[dq[-1]] <= nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # Add to result if window is complete
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result
        </div>

        <div class="complexity-analysis">
            <h4>Comprehensive Complexity Analysis:</h4>
            <ul>
                <li><strong>Deque Solution:</strong> O(n) time, O(k) space - optimal for single query</li>
                <li><strong>Segment Tree:</strong> O(n log n) preprocessing, O(log n) per query</li>
                <li><strong>Sparse Table:</strong> O(n log n) preprocessing, O(1) per query</li>
                <li><strong>Key Insight:</strong> Monotonic deque maintains candidates efficiently</li>
                <li><strong>Amortized Analysis:</strong> Each element added/removed at most once</li>
            </ul>
        </div>
    </div>

    <div class="content-section">
        <h2>üìä Quick Reference: Algorithm Complexity</h2>
        <div class="method-grid">
            <div class="method-item">
                <h5>Sorting Algorithms</h5>
                <ul>
                    <li>Quicksort: O(n log n) avg</li>
                    <li>Mergesort: O(n log n) always</li>
                    <li>Heapsort: O(n log n) always</li>
                    <li>Counting Sort: O(n + k)</li>
                </ul>
            </div>

            <div class="method-item">
                <h5>Graph Algorithms</h5>
                <ul>
                    <li>DFS/BFS: O(V + E)</li>
                    <li>Dijkstra: O((V + E) log V)</li>
                    <li>Floyd-Warshall: O(V¬≥)</li>
                    <li>Kruskal/Prim: O(E log V)</li>
                </ul>
            </div>

            <div class="method-item">
                <h5>Data Structures</h5>
                <ul>
                    <li>Hash Table: O(1) avg</li>
                    <li>Binary Heap: O(log n)</li>
                    <li>BST: O(log n) avg</li>
                    <li>Segment Tree: O(log n)</li>
                </ul>
            </div>

            <div class="method-item">
                <h5>Classic DP Problems</h5>
                <ul>
                    <li>Knapsack: O(nW)</li>
                    <li>LCS: O(mn)</li>
                    <li>Edit Distance: O(mn)</li>
                    <li>LIS: O(n log n)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="content-section">
        <h2>üéØ Scholarship Exam Strategy</h2>
        
        <div class="method-grid">
            <div class="method-item">
                <h5>1. Problem Understanding (5 min)</h5>
                <ul>
                    <li>Read problem twice carefully</li>
                    <li>Identify input/output specs</li>
                    <li>Note constraints and edge cases</li>
                    <li>Classify problem type</li>
                </ul>
            </div>

            <div class="method-item">
                <h5>2. Solution Design (15 min)</h5>
                <ul>
                    <li>Start with brute force</li>
                    <li>Identify optimizations</li>
                    <li>Choose optimal algorithm</li>
                    <li>Plan implementation</li>
                </ul>
            </div>

            <div class="method-item">
                <h5>3. Implementation (25 min)</h5>
                <ul>
                    <li>Write clean, structured code</li>
                    <li>Use meaningful names</li>
                    <li>Handle edge cases</li>
                    <li>Add comments for clarity</li>
                </ul>
            </div>

            <div class="method-item">
                <h5>4. Analysis & Reflection (15 min)</h5>
                <ul>
                    <li>Analyze time/space complexity</li>
                    <li>Justify algorithmic choices</li>
                    <li>Compare alternatives</li>
                    <li>Discuss optimization potential</li>
                </ul>
            </div>
        </div>

        <div class="scholarship-tips">
            <h3>Outstanding Scholarship Indicators</h3>
            <ul>
                <li><strong>Elegant Solutions:</strong> Clean, efficient code demonstrating deep understanding</li>
                <li><strong>Comprehensive Analysis:</strong> Thorough complexity analysis and optimization discussion</li>
                <li><strong>Independent Insights:</strong> Original observations beyond standard approaches</li>
                <li><strong>Complete Problem Solving:</strong> All three questions attempted with high-quality solutions</li>
                <li><strong>Critical Reflection:</strong> Thoughtful comparison of approaches and justification</li>
            </ul>
        </div>
    </div>

    <div class="content-section">
        <h2>üìö Additional Practice Resources</h2>
        
        <div class="highlight">
            <h4>Recommended Problem Sources:</h4>
            <ul>
                <li><strong><a href="https://leetcode.com/problemset/algorithms/" target="_blank">LeetCode</a></strong> - Focus on Medium/Hard problems</li>
                <li><strong><a href="https://codeforces.com/problemset" target="_blank">Codeforces</a></strong> - Competitive programming problems</li>
                <li><strong><a href="https://www.hackerrank.com/domains/algorithms" target="_blank">HackerRank</a></strong> - Algorithm challenges</li>
                <li><strong><a href="https://www.spoj.com/" target="_blank">SPOJ</a></strong> - Classical algorithms</li>
            </ul>
        </div>

        <div class="quick-reference">
            <h4>Study Schedule Template:</h4>
            <ul>
                <li><strong>Weeks 1-3:</strong> Foundation (sorting, searching, basic data structures)</li>
                <li><strong>Weeks 4-6:</strong> Advanced algorithms (DP, greedy, divide & conquer)</li>
                <li><strong>Weeks 7-9:</strong> Problem-solving patterns (two pointers, sliding window)</li>
                <li><strong>Weeks 10-12:</strong> Intensive practice and exam simulation</li>
            </ul>
        </div>
    </div>

    <div class="nav-buttons">
        <a href="index.html" class="prev-next-link">‚Üê Back to Study Guide</a>
        <div style="text-align: center;">
            <p><strong>Problems 1-5 of 20</strong><br>
            <small>Continue practicing with the remaining 15 problems using the patterns shown above</small></p>
        </div>
        <a href="index.html" class="prev-next-link">More Resources ‚Üí</a>
    </div>
</body>
</html>