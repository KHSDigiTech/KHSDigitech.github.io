<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Potential Scholarship Exam Problems</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #f5f5f5;
        }
        
        .header {
            background: linear-gradient(135deg, #7c3aed 0%, #4c1d95 100%);
            color: white;
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .problem-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin: 2rem 0;
        }
        
        .problem-card {
            background: white;
            border-radius: 10px;
            padding: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #7c3aed;
        }
        
        .problem-title {
            color: #4c1d95;
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.4rem;
            font-weight: 600;
        }
        
        .difficulty {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        
        .easy { background: #dcfce7; color: #166534; }
        .medium { background: #fef3c7; color: #92400e; }
        .hard { background: #fecaca; color: #991b1b; }
        
        .problem-description {
            background: #f8fafc;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #3b82f6;
        }
        
        .solution-approach {
            background: #f0fdf4;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #22c55e;
        }
        
        .complexity-analysis {
            background: #fef7ff;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #a855f7;
        }
        
        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 1rem 0;
        }
        
        .back-link {
            display: inline-block;
            margin-bottom: 1rem;
            color: #7c3aed;
            text-decoration: none;
        }

        .back-link:hover {
            text-decoration: underline;
        }
        
        .scholarship-tips {
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
        }
        
        .scholarship-tips h4 {
            color: #92400e;
            margin-top: 0;
        }
        
        .test-cases {
            background: #eff6ff;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #3b82f6;
        }
        
        .category-header {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 1.5rem;
            border-radius: 12px;
            border: 2px solid #7c3aed;
            margin: 2rem 0 1rem 0;
            text-align: center;
        }
        
        .category-header h2 {
            color: #4c1d95;
            margin: 0;
            font-size: 1.5rem;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Scholarship Study Guide</a>

    <div class="header">
        <h1>Potential Scholarship Exam Problems</h1>
        <p>Detailed Analysis with Time Complexity & Solution Approaches</p>
    </div>

    <div class="category-header">
        <h2>Category 1: Algorithm Analysis & String Manipulation</h2>
    </div>

    <div class="problem-grid">
        <div class="problem-card">
            <h3 class="problem-title">1. Palindrome Checker with Optimization</h3>
            <span class="difficulty medium">Medium</span>
            
            <div class="problem-description">
                <h4>Problem Statement:</h4>
                <p>Given a function that checks if a string is a palindrome by reversing the string and comparing, analyze its efficiency and create an optimized version. Handle edge cases and provide comprehensive testing.</p>
                
                <p><strong>Example Input:</strong> "racecar", "hello", "", "a"</p>
                <p><strong>Expected Skills:</strong> Code tracing, algorithm optimization, edge case handling</p>
            </div>

            <div class="solution-approach">
                <h4>Optimal Solution Approach:</h4>
                <ol>
                    <li><strong>Two-pointer technique:</strong> Compare characters from start and end moving inward</li>
                    <li><strong>Early termination:</strong> Return false immediately when mismatch found</li>
                    <li><strong>Case handling:</strong> Consider empty strings, single characters</li>
                    <li><strong>Space optimization:</strong> No additional string creation needed</li>
                </ol>
            </div>

            <div class="code-block">
def isPalindrome(s):
    if len(s) <= 1:
        return True
    
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True
            </div>

            <div class="complexity-analysis">
                <h4>Complexity Analysis:</h4>
                <ul>
                    <li><strong>Original (naive) approach:</strong> O(n) time, O(n) space (creates reversed string)</li>
                    <li><strong>Optimized approach:</strong> O(n) time, O(1) space</li>
                    <li><strong>Best case:</strong> O(1) when first and last characters differ</li>
                    <li><strong>Worst case:</strong> O(n) when string is palindrome or differs at center</li>
                </ul>
            </div>

            <div class="scholarship-tips">
                <h4>Scholarship-Level Analysis:</h4>
                <ul>
                    <li>Discuss why space optimization matters for large strings</li>
                    <li>Compare with other approaches (recursive, using built-in reverse)</li>
                    <li>Explain early termination benefits</li>
                    <li>Consider Unicode and case-sensitivity variations</li>
                </ul>
            </div>
        </div>

        <div class="problem-card">
            <h3 class="problem-title">2. Longest Common Substring</h3>
            <span class="difficulty hard">Hard</span>
            
            <div class="problem-description">
                <h4>Problem Statement:</h4>
                <p>Find the longest common substring between two strings. Optimize for both time and space complexity.</p>
                
                <p><strong>Example:</strong> "ABABC" and "BABCA" → "BABC" (length 4)</p>
                <p><strong>Expected Skills:</strong> Dynamic programming, space optimization, algorithm comparison</p>
            </div>

            <div class="solution-approach">
                <h4>Multiple Solution Approaches:</h4>
                <ol>
                    <li><strong>Brute Force:</strong> Check all substrings - O(n³) time</li>
                    <li><strong>Dynamic Programming:</strong> 2D table approach - O(n²) time, O(n²) space</li>
                    <li><strong>Space Optimized DP:</strong> Use rolling array - O(n²) time, O(n) space</li>
                    <li><strong>Suffix Array/Tree:</strong> Advanced approach - O(n log n) time</li>
                </ol>
            </div>

            <div class="complexity-analysis">
                <h4>DP Solution Analysis:</h4>
                <ul>
                    <li><strong>Time Complexity:</strong> O(m × n) where m, n are string lengths</li>
                    <li><strong>Space Complexity:</strong> O(min(m, n)) with optimization</li>
                    <li><strong>Recurrence:</strong> dp[i][j] = dp[i-1][j-1] + 1 if chars match, else 0</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="category-header">
        <h2>Category 2: Graph Theory & Pathfinding</h2>
    </div>

    <div class="problem-grid">
        <div class="problem-card">
            <h3 class="problem-title">3. Knight's Minimum Moves</h3>
            <span class="difficulty medium">Medium</span>
            
            <div class="problem-description">
                <h4>Problem Statement:</h4>
                <p>Calculate the minimum number of moves for a knight to travel from one square to another on an N×N chessboard. Handle multiple queries efficiently.</p>
                
                <p><strong>Input:</strong> Board size N, start position (x1,y1), end position (x2,y2)</p>
                <p><strong>Output:</strong> Minimum number of moves</p>
            </div>

            <div class="solution-approach">
                <h4>BFS Solution Approach:</h4>
                <ol>
                    <li><strong>Model as graph:</strong> Each square is a node, knight moves are edges</li>
                    <li><strong>BFS from start:</strong> Guarantees shortest path in unweighted graph</li>
                    <li><strong>8 possible moves:</strong> Knight's L-shaped movement pattern</li>
                    <li><strong>Boundary checking:</strong> Ensure moves stay within board</li>
                </ol>
            </div>

            <div class="code-block">
from collections import deque

def knightMinMoves(n, start, end):
    if start == end:
        return 0
    
    moves = [(-2,-1), (-2,1), (-1,-2), (-1,2), 
             (1,-2), (1,2), (2,-1), (2,1)]
    
    queue = deque([(start[0], start[1], 0)])
    visited = set([start])
    
    while queue:
        x, y, dist = queue.popleft()
        
        for dx, dy in moves:
            nx, ny = x + dx, y + dy
            
            if (0 <= nx < n and 0 <= ny < n and 
                (nx, ny) not in visited):
                
                if (nx, ny) == end:
                    return dist + 1
                
                queue.append((nx, ny, dist + 1))
                visited.add((nx, ny))
    
    return -1  # Should never reach here on valid board
            </div>

            <div class="complexity-analysis">
                <h4>Complexity Analysis:</h4>
                <ul>
                    <li><strong>Time Complexity:</strong> O(N²) - worst case visits all squares</li>
                    <li><strong>Space Complexity:</strong> O(N²) - for visited set and queue</li>
                    <li><strong>Optimal:</strong> BFS guarantees minimum moves (shortest path)</li>
                    <li><strong>Alternative:</strong> A* with Manhattan distance heuristic for larger boards</li>
                </ul>
            </div>

            <div class="test-cases">
                <h4>Test Cases to Consider:</h4>
                <ul>
                    <li><strong>Same position:</strong> (1,1) to (1,1) → 0 moves</li>
                    <li><strong>Adjacent squares:</strong> Often require 3 moves due to knight movement</li>
                    <li><strong>Opposite corners:</strong> Maximum distance on board</li>
                    <li><strong>Minimum board size:</strong> 4×4 (smaller boards may have unreachable squares)</li>
                </ul>
            </div>
        </div>

        <div class="problem-card">
            <h3 class="problem-title">4. Maze Shortest Path with Obstacles</h3>
            <span class="difficulty hard">Hard</span>
            
            <div class="problem-description">
                <h4>Problem Statement:</h4>
                <p>Find shortest path in a grid maze with obstacles. Handle multiple queries and optimize for repeated searches.</p>
                
                <p><strong>Input:</strong> Grid with 0s (walkable) and 1s (obstacles), start/end coordinates</p>
                <p><strong>Variations:</strong> Weighted edges, multiple destinations, dynamic obstacles</p>
            </div>

            <div class="solution-approach">
                <h4>Advanced Solution Approaches:</h4>
                <ol>
                    <li><strong>Basic BFS:</strong> Standard approach for unweighted grid</li>
                    <li><strong>Dijkstra's Algorithm:</strong> For weighted grids</li>
                    <li><strong>A* Search:</strong> With Manhattan/Euclidean distance heuristic</li>
                    <li><strong>Bidirectional BFS:</strong> Search from both ends simultaneously</li>
                </ol>
            </div>

            <div class="complexity-analysis">
                <h4>Complexity Comparison:</h4>
                <ul>
                    <li><strong>BFS:</strong> O(V + E) = O(mn) for grid, where m×n is grid size</li>
                    <li><strong>Dijkstra:</strong> O((V + E) log V) = O(mn log(mn))</li>
                    <li><strong>A*:</strong> O(b^d) where b is branching factor, d is depth</li>
                    <li><strong>Bidirectional BFS:</strong> O(b^(d/2)) - significant improvement</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="category-header">
        <h2>Category 3: Dynamic Programming & Optimization</h2>
    </div>

    <div class="problem-grid">
        <div class="problem-card">
            <h3 class="problem-title">5. 0/1 Knapsack Problem</h3>
            <span class="difficulty medium">Medium</span>
            
            <div class="problem-description">
                <h4>Problem Statement:</h4>
                <p>Given items with weights and values, and a knapsack capacity, find the maximum value that can be achieved. Items cannot be split.</p>
                
                <p><strong>Example:</strong> Capacity=5, Items=[(weight=1,value=3), (2,5), (5,7)] → Max value=8</p>
                <p><strong>Expected Skills:</strong> DP optimization, space complexity reduction, solution reconstruction</p>
            </div>

            <div class="solution-approach">
                <h4>Progressive Solution Development:</h4>
                <ol>
                    <li><strong>Recursive with Memoization:</strong> Top-down approach</li>
                    <li><strong>2D DP Table:</strong> Bottom-up with full table</li>
                    <li><strong>Space Optimized:</strong> 1D array using rolling technique</li>
                    <li><strong>Solution Tracking:</strong> Reconstruct which items were selected</li>
                </ol>
            </div>

            <div class="code-block">
def knapsack_optimized(capacity, weights, values, n):
    # Space optimized DP - O(capacity) space
    dp = [0] * (capacity + 1)
    
    for i in range(n):
        # Traverse backwards to avoid using updated values
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], 
                       dp[w - weights[i]] + values[i])
    
    return dp[capacity]

def knapsack_with_solution(capacity, weights, values, n):
    # 2D DP to track solution
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], 
                              dp[i-1][w])
            else:
                dp[i][w] = dp[i-1][w]
    
    # Reconstruct solution
    selected = []
    w = capacity
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i-1][w]:
            selected.append(i-1)
            w -= weights[i-1]
    
    return dp[n][capacity], selected[::-1]
            </div>

            <div class="complexity-analysis">
                <h4>Complexity Analysis:</h4>
                <ul>
                    <li><strong>Time Complexity:</strong> O(n × capacity) for all approaches</li>
                    <li><strong>Space Complexity:</strong></li>
                    <ul>
                        <li>2D DP: O(n × capacity)</li>
                        <li>Space optimized: O(capacity)</li>
                        <li>With solution tracking: O(n × capacity)</li>
                    </ul>
                    <li><strong>Pseudo-polynomial:</strong> Complexity depends on capacity value, not input size</li>
                </ul>
            </div>

            <div class="scholarship-tips">
                <h4>Scholarship Analysis Points:</h4>
                <ul>
                    <li>Explain why greedy approach fails (value/weight ratio)</li>
                    <li>Discuss space-time tradeoff between optimized and solution-tracking versions</li>
                    <li>Compare with fractional knapsack (greedy works there)</li>
                    <li>Mention NP-completeness and why DP is pseudo-polynomial</li>
                </ul>
            </div>
        </div>

        <div class="problem-card">
            <h3 class="problem-title">6. Longest Increasing Subsequence</h3>
            <span class="difficulty hard">Hard</span>
            
            <div class="problem-description">
                <h4>Problem Statement:</h4>
                <p>Find the length of the longest increasing subsequence in an array. Optimize beyond the standard O(n²) solution.</p>
                
                <p><strong>Example:</strong> [10,9,2,5,3,7,101,18] → [2,3,7,18] (length 4)</p>
                <p><strong>Expected Skills:</strong> Binary search optimization, algorithm improvement</p>
            </div>

            <div class="solution-approach">
                <h4>Evolution of Solutions:</h4>
                <ol>
                    <li><strong>Brute Force:</strong> Check all subsequences - O(2^n)</li>
                    <li><strong>Basic DP:</strong> For each element, check all previous - O(n²)</li>
                    <li><strong>Binary Search + DP:</strong> Maintain sorted array - O(n log n)</li>
                    <li><strong>Patience Sorting:</strong> Alternative view of optimal solution</li>
                </ol>
            </div>

            <div class="code-block">
def lengthOfLIS_optimal(nums):
    if not nums:
        return 0
    
    # tails[i] = smallest ending element of LIS of length i+1
    tails = []
    
    for num in nums:
        # Binary search for position to replace/append
        left, right = 0, len(tails)
        while left < right:
            mid = (left + right) // 2
            if tails[mid] < num:
                left = mid + 1
            else:
                right = mid
        
        # If num is larger than all elements, append
        if left == len(tails):
            tails.append(num)
        else:
            # Replace first element >= num
            tails[left] = num
    
    return len(tails)
            </div>

            <div class="complexity-analysis">
                <h4>Complexity Progression:</h4>
                <ul>
                    <li><strong>O(n²) DP:</strong> Simple but inefficient for large inputs</li>
                    <li><strong>O(n log n) Optimized:</strong> Uses binary search insight</li>
                    <li><strong>Space:</strong> O(n) for both approaches</li>
                    <li><strong>Key insight:</strong> We only need to track smallest tail for each length</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="category-header">
        <h2>Category 4: Advanced Data Structures & Algorithms</h2>
    </div>

    <div class="problem-grid">
        <div class="problem-card">
            <h3 class="problem-title">7. Range Sum Query with Updates</h3>
            <span class="difficulty hard">Hard</span>
            
            <div class="problem-description">
                <h4>Problem Statement:</h4>
                <p>Design a data structure that supports range sum queries and single element updates efficiently.</p>
                
                <p><strong>Operations:</strong> update(index, value), sumRange(left, right)</p>
                <p><strong>Expected Skills:</strong> Advanced data structures, amortized analysis</p>
            </div>

            <div class="solution-approach">
                <h4>Data Structure Options:</h4>
                <ol>
                    <li><strong>Naive Array:</strong> Update O(1), Query O(n)</li>
                    <li><strong>Prefix Sum Array:</strong> Update O(n), Query O(1)</li>
                    <li><strong>Square Root Decomposition:</strong> Both O(√n)</li>
                    <li><strong>Segment Tree:</strong> Both O(log n) - optimal</li>
                    <li><strong>Fenwick Tree (BIT):</strong> Both O(log n), less memory</li>
                </ol>
            </div>

            <div class="complexity-analysis">
                <h4>Segment Tree Analysis:</h4>
                <ul>
                    <li><strong>Build Time:</strong> O(n)</li>
                    <li><strong>Update Time:</strong> O(log n)</li>
                    <li><strong>Query Time:</strong> O(log n)</li>
                    <li><strong>Space:</strong> O(4n) ≈ O(n)</li>
                    <li><strong>Advantage:</strong> Generalizable to other range operations (min, max, etc.)</li>
                </ul>
            </div>
        </div>

        <div class="problem-card">
            <h3 class="problem-title">8. Sliding Window Maximum</h3>
            <span class="difficulty hard">Hard</span>
            
            <div class="problem-description">
                <h4>Problem Statement:</h4>
                <p>Given an array and window size k, find the maximum element in each sliding window.</p>
                
                <p><strong>Example:</strong> [1,3,-1,-3,5,3,6,7], k=3 → [3,3,5,5,6,7]</p>
                <p><strong>Expected Skills:</strong> Deque usage, amortized complexity analysis</p>
            </div>

            <div class="solution-approach">
                <h4>Solution Approaches:</h4>
                <ol>
                    <li><strong>Brute Force:</strong> Check each window - O(nk)</li>
                    <li><strong>Deque (Monotonic Queue):</strong> Maintain decreasing order - O(n)</li>
                    <li><strong>Segment Tree:</strong> Range max queries - O(n log n)</li>
                    <li><strong>Sparse Table:</strong> Precomputed range queries - O(n log n) preprocessing</li>
                </ol>
            </div>

            <div class="complexity-analysis">
                <h4>Deque Solution Analysis:</h4>
                <ul>
                    <li><strong>Time Complexity:</strong> O(n) - each element added/removed at most once</li>
                    <li><strong>Space Complexity:</strong> O(k) for deque storage</li>
                    <li><strong>Key Insight:</strong> Maintain indices in decreasing order of their values</li>
                    <li><strong>Amortized Analysis:</strong> Each element is processed at most twice</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="category-header">
        <h2>Category 5: Mathematical & Number Theory</h2>
    </div>

    <div class="problem-grid">
        <div class="problem-card">
            <h3 class="problem-title">9. Prime Number Generation</h3>
            <span class="difficulty medium">Medium</span>
            
            <div class="problem-description">
                <h4>Problem Statement:</h4>
                <p>Generate all prime numbers up to n efficiently. Compare different algorithms and analyze their complexity.</p>
                
                <p><strong>Expected Skills:</strong> Mathematical optimization, algorithm comparison, memory efficiency</p>
            </div>

            <div class="solution-approach">
                <h4>Algorithm Progression:</h4>
                <ol>
                    <li><strong>Trial Division:</strong> Check each number for divisibility</li>
                    <li><strong>Optimized Trial Division:</strong> Check only up to √n</li>
                    <li><strong>Sieve of Eratosthenes:</strong> Mark multiples as composite</li>
                    <li><strong>Segmented Sieve:</strong> Memory-efficient for large ranges</li>
                </ol>
            </div>

            <div class="complexity-analysis">
                <h4>Complexity Comparison:</h4>
                <ul>
                    <li><strong>Trial Division:</strong> O(n² / log n) - checking each number</li>
                    <li><strong>Sieve of Eratosthenes:</strong> O(n log log n) time, O(n) space</li>
                    <li><strong>Space Optimization:</strong> Can reduce to O(√n) space with segmented sieve</li>
                    <li><strong>Practical Optimizations:</strong> Wheel factorization, bit packing</li>
                </ul>
            </div>
        </div>

        <div class="problem-card">
            <h3 class="problem-title">10. Fast Exponentiation</h3>
            <span class="difficulty medium">Medium</span>
            
            <div class="problem-description">
                <h4>Problem Statement:</h4>
                <p>Compute a^b mod m efficiently for large values. Handle edge cases and optimize for different input ranges.</p>
                
                <p><strong>Applications:</strong> Cryptography, number theory, mathematical computations</p>
                <p><strong>Expected Skills:</strong> Bit manipulation, modular arithmetic, recursion vs iteration</p>
            </div>

            <div class="solution-approach">
                <h4>Algorithm Approaches:</h4>
                <ol>
                    <li><strong>Naive:</strong> Multiply a by itself b times</li>
                    <li><strong>Binary Exponentiation:</strong> Use binary representation of exponent</li>
                    <li><strong>Recursive:</strong> a^b = (a^(b/2))² * a^(b%2)</li>
                    <li><strong>Iterative:</strong> Build result using bit shifts</li>
                </ol>
            </div>

            <div class="code-block">
def fast_power(base, exp, mod):
    result = 1
    base = base % mod
    
    while exp > 0:
        # If exp is odd, multiply base with result
        if exp % 2 == 1:
            result = (result * base) % mod
        
        # Now exp must be even
        exp = exp // 2
        base = (base * base) % mod
    
    return result

# Alternative recursive approach
def fast_power_recursive(base, exp, mod):
    if exp == 0:
        return 1
    
    if exp % 2 == 0:
        half = fast_power_recursive(base, exp // 2, mod)
        return (half * half) % mod
    else:
        return (base * fast_power_recursive(base, exp - 1, mod)) % mod
            </div>

            <div class="complexity-analysis">
                <h4>Complexity Analysis:</h4>
                <ul>
                    <li><strong>Time Complexity:</strong> O(log b) - reduces exponent by half each step</li>
                    <li><strong>Space Complexity:</strong> O(1) iterative, O(log b) recursive (call stack)</li>
                    <li><strong>Comparison with naive:</strong> O(b) vs O(log b) - exponential improvement</li>
                    <li><strong>Modular arithmetic:</strong> Prevents integer overflow</li>
                </ul>
            </div>

            <div class="scholarship-tips">
                <h4>Advanced Analysis:</h4>
                <ul>
                    <li>Explain bit manipulation insight: exponent's binary representation</li>
                    <li>Discuss overflow prevention with modular arithmetic</li>
                    <li>Compare recursive vs iterative trade-offs</li>
                    <li>Mention applications in RSA cryptography and number theory</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="scholarship-tips">
        <h3>Scholarship Exam Mastery Framework</h3>
        
        <div class="highlight">
            <h4>Sample Problem Types from Past Exams:</h4>
            <ul>
                <li><strong>2023:</strong> Graph pathfinding with constraints, dynamic programming optimization, string processing</li>
                <li><strong>2022:</strong> Tree algorithms, computational geometry, advanced data structures</li>
                <li><strong>2021:</strong> Network flow, game theory, mathematical algorithms</li>
                <li><strong>Common Themes:</strong> Optimization problems, algorithmic efficiency, critical analysis of trade-offs</li>
            </ul>
        </div>
        
        <h4>Problem-Solving Methodology:</h4>
        <div class="performance-grid">
            <div class="performance-item">
                <h4>1. Problem Understanding (5 minutes)</h4>
                <ul>
                    <li>Read problem statement twice carefully</li>
                    <li>Identify input/output specifications</li>
                    <li>Note constraints and edge cases</li>
                    <li>Classify problem type (DP, graph, greedy, etc.)</li>
                    <li>Estimate expected time complexity</li>
                </ul>
            </div>

            <div class="performance-item">
                <h4>2. Solution Design (15 minutes)</h4>
                <ul>
                    <li>Start with brute force approach</li>
                    <li>Identify optimization opportunities</li>
                    <li>Choose optimal algorithm/data structure</li>
                    <li>Plan implementation strategy</li>
                    <li>Consider multiple solution approaches</li>
                </ul>
            </div>

            <div class="performance-item">
                <h4>3. Implementation (25 minutes)</h4>
                <ul>
                    <li>Write clean, well-structured code</li>
                    <li>Use meaningful variable names</li>
                    <li>Handle edge cases explicitly</li>
                    <li>Add comments for complex logic</li>
                    <li>Trace through example inputs</li>
                </ul>
            </div>

            <div class="performance-item">
                <h4>4. Analysis & Reflection (15 minutes)</h4>
                <ul>
                    <li>Analyze time and space complexity</li>
                    <li>Justify algorithmic choices</li>
                    <li>Compare with alternative approaches</li>
                    <li>Discuss optimization potential</li>
                    <li>Consider real-world applications</li>
                </ul>
            </div>
        </div>
        
        <h4>Critical Analysis Framework:</h4>
        <ul>
            <li><strong>Algorithmic Justification:</strong> Why is this approach optimal for the given constraints?</li>
            <li><strong>Complexity Trade-offs:</strong> Discuss time vs space efficiency decisions</li>
            <li><strong>Alternative Approaches:</strong> What other solutions exist and their comparative analysis</li>
            <li><strong>Scalability Assessment:</strong> Performance with increasing input sizes</li>
            <li><strong>Edge Case Handling:</strong> Comprehensive boundary condition analysis</li>
            <li><strong>Implementation Quality:</strong> Code clarity, maintainability, and efficiency</li>
            <li><strong>Real-world Context:</strong> Practical applications and industry relevance</li>
        </ul>

        <h4>Common Pitfalls to Avoid:</h4>
        <ul>
            <li><strong>Rushing to code:</strong> Always plan your approach thoroughly first</li>
            <li><strong>Ignoring edge cases:</strong> Empty inputs, single elements, maximum constraints</li>
            <li><strong>Suboptimal solutions:</strong> Don't settle for brute force when optimization is possible</li>
            <li><strong>Poor code quality:</strong> Unreadable variable names, no comments, poor structure</li>
            <li><strong>Incomplete analysis:</strong> Missing complexity analysis or algorithmic justification</li>
            <li><strong>No alternative discussion:</strong> Failing to consider other approaches</li>
        </ul>

        <h4>Outstanding Scholarship Indicators:</h4>
        <ul>
            <li><strong>Elegant Solutions:</strong> Clean, efficient code that demonstrates deep understanding</li>
            <li><strong>Comprehensive Analysis:</strong> Thorough complexity analysis and optimization discussion</li>
            <li><strong>Independent Insights:</strong> Original observations beyond standard textbook approaches</li>
            <li><strong>Complete Problem Solving:</strong> All three questions attempted with high-quality solutions</li>
            <li><strong>Critical Reflection:</strong> Thoughtful comparison of approaches and justification of choices</li>
            <li><strong>Advanced Techniques:</strong> Use of sophisticated algorithms appropriate to the problem</li>
            <li><strong>Error-free Implementation:</strong> Code that would run correctly without debugging</li>
        </ul>
        
        <div class="highlight">
            <h4>Final Exam Day Tips:</h4>
            <ul>
                <li><strong>Time Management:</strong> Spend ~60 minutes per question, leave 15 minutes for review</li>
                <li><strong>Read All Questions First:</strong> Start with your strongest area to build confidence</li>
                <li><strong>Plan Before Coding:</strong> Spend 10-15 minutes designing your approach</li>
                <li><strong>Code Quality Matters:</strong> Clean, readable code demonstrates understanding</li>
                <li><strong>Show Your Work:</strong> Include complexity analysis and algorithmic justification</li>
                <li><strong>Double-Check Edge Cases:</strong> Empty inputs, single elements, boundary conditions</li>
            </ul>
        </div>
    </div>
    
    <div class="assessment-card">
        <h3>Quick Reference: Algorithm Complexity Cheat Sheet</h3>
        <div class="performance-grid">
            <div class="performance-item">
                <h4>Sorting Algorithms</h4>
                <ul>
                    <li>Quicksort: O(n log n) avg, O(n²) worst</li>
                    <li>Mergesort: O(n log n) always</li>
                    <li>Heapsort: O(n log n) always</li>
                    <li>Counting Sort: O(n + k) for range k</li>
                </ul>
            </div>

            <div class="performance-item">
                <h4>Graph Algorithms</h4>
                <ul>
                    <li>DFS/BFS: O(V + E)</li>
                    <li>Dijkstra: O((V + E) log V)</li>
                    <li>Floyd-Warshall: O(V³)</li>
                    <li>Kruskal/Prim MST: O(E log V)</li>
                </ul>
            </div>

            <div class="performance-item">
                <h4>Data Structures</h4>
                <ul>
                    <li>Hash Table: O(1) avg, O(n) worst</li>
                    <li>Binary Heap: O(log n) insert/delete</li>
                    <li>BST: O(log n) avg, O(n) worst</li>
                    <li>Segment Tree: O(log n) query/update</li>
                </ul>
            </div>

            <div class="performance-item">
                <h4>Classic DP Problems</h4>
                <ul>
                    <li>Knapsack: O(nW) time, O(W) space</li>
                    <li>LCS: O(mn) time, O(min(m,n)) space</li>
                    <li>Edit Distance: O(mn) time, O(min(m,n)) space</li>
                    <li>LIS: O(n log n) optimized</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="intro-section">
        <h2>Additional Practice Resources</h2>
        
        <div class="highlight">
            <h4>Recommended Problem Sources:</h4>
            <ul>
                <li><strong><a href="https://leetcode.com/problemset/algorithms/" target="_blank">LeetCode</a></strong> - Focus on Medium/Hard problems, especially top interview questions</li>
                <li><strong><a href="https://codeforces.com/problemset" target="_blank">Codeforces</a></strong> - Competitive programming problems (Div 2 C/D level)</li>
                <li><strong><a href="https://www.hackerrank.com/domains/algorithms" target="_blank">HackerRank</a></strong> - Algorithm challenges with clear explanations</li>
                <li><strong><a href="https://www.spoj.com/" target="_blank">SPOJ</a></strong> - Classical algorithms and data structures</li>
                <li><strong><a href="https://uva.onlinejudge.org/" target="_blank">UVa Online Judge</a></strong> - Programming contest problems</li>
            </ul>
        </div>

        <div class="highlight">
            <h4>Books for Deep Understanding:</h4>
            <ul>
                <li><strong>"Introduction to Algorithms" (CLRS)</strong> - Comprehensive algorithmic foundation</li>
                <li><strong>"Algorithm Design Manual" (Skiena)</strong> - Practical problem-solving approaches</li>
                <li><strong>"Programming Pearls" (Bentley)</strong> - Elegant problem-solving techniques</li>
                <li><strong>"Competitive Programming" (Halim & Halim)</strong> - Contest-style problem solving</li>
            </ul>
        </div>

        <div class="highlight">
            <h4>Online Courses & Tutorials:</h4>
            <ul>
                <li><strong><a href="https://www.coursera.org/specializations/algorithms" target="_blank">Stanford Algorithms Specialization</a></strong> - Tim Roughgarden's excellent series</li>
                <li><strong><a href="https://www.edx.org/course/algorithm-design-and-analysis" target="_blank">MIT Algorithm Design</a></strong> - Theoretical foundations</li>
                <li><strong><a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank">MIT 6.006</a></strong> - Introduction to Algorithms lectures</li>
                <li><strong><a href="https://www.youtube.com/c/WilliamFiset-videos" target="_blank">William Fiset</a></strong> - Clear algorithm explanations with code</li>
            </ul>
        </div>
    </div>
    
    <div class="intro-section">
        <h2>Study Schedule Template</h2>
        
        <div class="assessment-card">
            <h3>12-Week Scholarship Preparation Plan</h3>
            
            <h4>Weeks 1-3: Foundation (Algorithms & Data Structures)</h4>
            <ul>
                <li><strong>Week 1:</strong> Sorting, searching, basic data structures (arrays, linked lists, stacks, queues)</li>
                <li><strong>Week 2:</strong> Trees, BST, heaps, hash tables</li>
                <li><strong>Week 3:</strong> Graph representation, DFS, BFS, basic graph algorithms</li>
            </ul>
            
            <h4>Weeks 4-6: Advanced Algorithms</h4>
            <ul>
                <li><strong>Week 4:</strong> Dynamic programming (1D and 2D), classical problems</li>
                <li><strong>Week 5:</strong> Greedy algorithms, divide & conquer</li>
                <li><strong>Week 6:</strong> Advanced graph algorithms (shortest paths, MST, topological sort)</li>
            </ul>
            
            <h4>Weeks 7-9: Problem-Solving Patterns</h4>
            <ul>
                <li><strong>Week 7:</strong> Two pointers, sliding window, binary search variations</li>
                <li><strong>Week 8:</strong> Advanced data structures (segment trees, tries, union-find)</li>
                <li><strong>Week 9:</strong> Mathematical algorithms, number theory, computational geometry</li>
            </ul>
            
            <h4>Weeks 10-12: Intensive Practice</h4>
            <ul>
                <li><strong>Week 10:</strong> Mixed problem practice, focus on weak areas</li>
                <li><strong>Week 11:</strong> Timed 3-hour practice sessions, exam simulation</li>
                <li><strong>Week 12:</strong> Review fundamentals, final practice, exam preparation</li>
            </ul>
        </div>
    </div>
</body>
</html>